<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>Elysia 3D 展示（带透明水波）</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #07030a;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* 全屏容器：图片铺满屏幕（cover），居中显示 */
  #elysia-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    perspective: 900px;
    display: block;
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
    background: #000;
  }

  /* 主图、深度图、高光层：覆盖整个容器 */
  #elysia-img, #elysia-depth {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    transform-style: preserve-3d;
    transition: transform 220ms ease-out;
    will-change: transform;
    -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
  }

  #elysia-depth {
    mix-blend-mode: multiply;
    opacity: 0.62;
    pointer-events: none;
    transition: transform 260ms ease-out, opacity 420ms ease;
    will-change: transform, opacity;
  }

  /* 高光呼吸层（人物高光） */
  #elysia-highlight {
    position: absolute;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: soft-light;
    background: radial-gradient(circle at 50% 30%, rgba(255,255,255,0.36), transparent 60%);
    transition: background 200ms ease-out, opacity 300ms ease;
    opacity: 1;
    will-change: background, opacity, transform;
    animation: highlightBreathing 2.8s ease-in-out infinite;
  }

  @keyframes highlightBreathing {
    0% {
      opacity: 0.55;
      transform: scale(1);
      filter: blur(8px);
    }
    50% {
      opacity: 1;
      transform: scale(1.06);
      filter: blur(16px);
    }
    100% {
      opacity: 0.55;
      transform: scale(1);
      filter: blur(8px);
    }
  }

  /* 两条纯黑竖线，宽 10px，分成三等分 */
  .divider {
    position: absolute;
    top: 0;
    height: 100%;
    width: 10px;               /* 你要的粗度 */
    background: #000;          /* 纯黑 */
    z-index: 6;
    pointer-events: none;
    box-shadow: 0 0 8px rgba(0,0,0,0.25) inset;
  }
  #divider1 { left: calc(100%/3 - 5px); } /* 居中对齐 1/3 线（减半宽度） */
  #divider2 { left: calc(200%/3 - 5px); }

  /* 水波（放大折射）容器：动态创建的 .ripple 元素会放这里 */
  .ripple {
    position: absolute;
    width: 120px;    /* 初始大小，动画中会放大 */
    height: 120px;
    border-radius: 50%;
    overflow: hidden;
    pointer-events: none;
    z-index: 8;      /* 高于图片与深度图，但低于分割线（如果你想线在上面可调） */
    transform: translate(-50%, -50%) scale(0.6);
    opacity: 0.95;
    will-change: transform, opacity, background-position, width, height;
    transition: none;
    box-shadow: 0 8px 28px rgba(10,6,20,0.35);
    isolation: isolate;
  }

  /* ripple 内的放大背景层（使用与主图相同的图片作为背景，并稍微放大） */
  .ripple .ripple-bg {
    position: absolute;
    inset: 0;
    background-size: calc(100% + 8%) calc(100% + 8%); /* 放大比例，制造“透过水波放大” */
    background-repeat: no-repeat;
    background-position: center center;
    transform-origin: center center;
    filter: saturate(1.02) contrast(1.04);
  }

  /* 水波外层半透明边缘（用渐变 + blur 制造柔和透明圈） */
  .ripple::after {
    content: "";
    position: absolute;
    inset: -10%;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,255,255,0.06), rgba(255,255,255,0.02) 40%, rgba(255,255,255,0.00) 60%);
    filter: blur(6px);
    pointer-events: none;
    mix-blend-mode: screen;
  }

  /* ripple 的动画（放大 + 透明淡出） */
  @keyframes rippleExpand {
    0% {
      transform: translate(-50%, -50%) scale(0.6);
      opacity: 0.95;
    }
    70% {
      transform: translate(-50%, -50%) scale(2.6);
      opacity: 0.42;
    }
    100% {
      transform: translate(-50%, -50%) scale(3.3);
      opacity: 0;
    }
  }

  /* 更细腻的内部位移动画（微小晃动） */
  @keyframes rippleWobble {
    0% { transform: translate(0,0) scale(1); }
    50% { transform: translate(1.2px,-0.8px) scale(1.01); }
    100% { transform: translate(0,0) scale(1); }
  }

  /* 鼠标轻微倾斜效果（幅度变小） */
  #elysia-container.tilt .img-tilt {
    transition: transform 220ms cubic-bezier(.2,.9,.25,1);
  }

  /* 轻柔整体呼吸浮动（页面感觉更生动） */
  @keyframes pageFloat {
    0%,100% { transform: translateY(0); }
    50% { transform: translateY(-4px); }
  }
  #elysia-container {
    animation: pageFloat 9s ease-in-out infinite;
  }

  /* 辅助：确保在小屏上不会出现滚动条 */
  @media (max-width: 700px) {
    .ripple { width: 100px; height: 100px; }
  }
</style>
</head>
<body>
  <div id="elysia-container" aria-hidden="false">
    <!-- 主图 & 深度图 -->
    <img id="elysia-img" class="img-tilt" src="assets/wallhaven-7p1v79.jpg" alt="Elysia">
    <img id="elysia-depth" class="img-tilt" src="assets/wallhaven-7p1v79-deepth.png" alt="Depth">
    <div id="elysia-highlight" aria-hidden="true"></div>

    <!-- 两条黑色竖线（10px） -->
    <div id="divider1" class="divider" aria-hidden="true"></div>
    <div id="divider2" class="divider" aria-hidden="true"></div>

    <!-- ripple 的容器（动态插入 ripple DOM） -->
    <div id="ripple-layer" aria-hidden="true"></div>
  </div>

<script>
/* ========= 主交互逻辑 ========= */
const container = document.getElementById('elysia-container');
const mainImg = document.getElementById('elysia-img');
const depthImg = document.getElementById('elysia-depth');
const highlight = document.getElementById('elysia-highlight');
const rippleLayer = document.getElementById('ripple-layer');

/* 鼠标 / 触摸更新：较小的倾斜量用来营造 3D 感 */
function updateTilt(clientX, clientY) {
  const rect = container.getBoundingClientRect();
  const cx = clientX - rect.left;
  const cy = clientY - rect.top;
  const rx = ((cx / rect.width) - 0.5) * 8;   // Y 旋转（更小幅度）
  const ry = ((cy / rect.height) - 0.5) * -6; // X 旋转（更小幅度）

  // 将 transform 限制在小范围内，避免过度倾斜
  mainImg.style.transform = `rotateY(${rx}deg) rotateX(${ry}deg) scale(1.01)`;
  depthImg.style.transform = `rotateY(${rx * 1.25}deg) rotateX(${ry * 1.25}deg) scale(1.01)`;

  // 高光位置随指针移动（弱幅度）
  const posX = 50 + rx * 1.1;
  const posY = 35 + ry * 1.1;
  highlight.style.background = `radial-gradient(circle at ${posX}% ${posY}%, rgba(255,255,255,0.4), transparent 60%)`;
}

/* 鼠标事件：移动 & 离开 */
document.addEventListener('mousemove', e => {
  updateTilt(e.clientX, e.clientY);
});
document.addEventListener('mouseleave', () => {
  // 复位
  mainImg.style.transform = 'rotateY(0deg) rotateX(0deg) scale(1)';
  depthImg.style.transform = 'rotateY(0deg) rotateX(0deg) scale(1)';
  highlight.style.background = 'radial-gradient(circle at 50% 30%, rgba(255,255,255,0.36), transparent 60%)';
});

/* 移动端触摸支持 */
document.addEventListener('touchmove', e => {
  const t = e.touches[0];
  if (t) updateTilt(t.clientX, t.clientY);
}, {passive: true});
document.addEventListener('touchend', () => {
  mainImg.style.transform = 'rotateY(0deg) rotateX(0deg) scale(1)';
  depthImg.style.transform = 'rotateY(0deg) rotateX(0deg) scale(1)';
  highlight.style.background = 'radial-gradient(circle at 50% 30%, rgba(255,255,255,0.36), transparent 60%)';
});

/* ========== 水波逻辑 ========== */
/*
  实现思路：
  - 点击位置创建一个 .ripple 元素（圆形 div）
  - 使用与主图相同的图片作为 .ripple 内部背景（background-position 对齐到点击点）
  - 将背景略微放大（background-size > 100%）以模拟“透过水波放大”的折射感
  - 动画通过 CSS keyframes 扩大 .ripple 并降低 opacity（最后删除 DOM）
*/

function createRipple(clientX, clientY) {
  const rect = container.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;

  // ripple 基本尺寸（可改）
  const baseSize = Math.max(rect.width, rect.height) * 0.12; // 起始较大一些
  const ripple = document.createElement('div');
  ripple.className = 'ripple';
  ripple.style.width = `${baseSize}px`;
  ripple.style.height = `${baseSize}px`;
  ripple.style.left = `${x}px`;
  ripple.style.top = `${y}px`;

  // 内部背景层：与主图相同图片，background-position 需计算以对齐源图
  const bg = document.createElement('div');
  bg.className = 'ripple-bg';
  // 使用 mainImg.src 作为背景（你可改成更适合的高清图）
  bg.style.backgroundImage = `url("${mainImg.src}")`;

  // 计算 background-position：使得在点击点处背景对齐主图的对应像素
  // 计算百分比位置
  const posXPercent = (x / rect.width) * 100;
  const posYPercent = (y / rect.height) * 100;
  // 因为我们把 background-size 放大了一点 (calc(100% + 8%))，此处不用额外修正
  bg.style.backgroundPosition = `${posXPercent}% ${posYPercent}%`;

  // 放入 ripple
  ripple.appendChild(bg);
  rippleLayer.appendChild(ripple);

  // 强制回流，随后启动动画
  // set CSS 动画（用 JS 触发以便重复可用）
  requestAnimationFrame(() => {
    ripple.style.animation = 'rippleExpand 900ms cubic-bezier(.2,.9,.2,1) forwards';
    // 轻微内部 wobble，让折射感更真实
    bg.style.animation = 'rippleWobble 900ms ease-in-out forwards';
  });

  // 清理：动画结束后移除节点
  setTimeout(() => {
    if (ripple && ripple.parentNode) ripple.parentNode.removeChild(ripple);
  }, 1000);
}

/* 点击 / 触摸触发 */
container.addEventListener('click', (e) => {
  // 忽略如果用户是在拖动滚动或触发其他 UI：但这里直接触发
  createRipple(e.clientX, e.clientY);
});

container.addEventListener('touchstart', (e) => {
  const t = e.touches[0];
  if (t) createRipple(t.clientX, t.clientY);
}, {passive: true});

/* 可选：按键触发测试（按空格触发中心水波）*/
document.addEventListener('keydown', (e) => {
  if (e.key === ' ') {
    const rect = container.getBoundingClientRect();
    createRipple(rect.width/2, rect.height/2);
  }
});
</script>
</body>
</html>